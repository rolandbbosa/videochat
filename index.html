

<html>
  <head>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">

    <style>
        .video-container {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}
video {
  background-color: #ddd;
  border-radius: 7px;
  margin: 10px;
  width: 320px;
  height: 240px;
  max-width: 45%;
}
button {
  margin: 5px;
  width: 150px;
}
.spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  animation: spin 2s linear infinite;
  display: inline-block;
  margin-left: 10px;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
@media (max-width: 768px) {
  .video-container {
    flex-direction: column;
    align-items: center;
  }
  video {
    width: 90%;
    max-width: none;
    height: auto;
  }
  button {
    width: 90%;
    margin: 5px auto;
  }
}
    </style>
  </head>
  <body>
    <div class="video-container">
      <video id="yourVideo" autoplay muted playsinline></video>
      <video id="friendsVideo" autoplay playsinline></video>
    </div>
    <br />
    <div id="status" style="margin: 10px; font-weight: bold; text-align: center;">Status: Idle</div>
    <div id="spinner" style="display: none; text-align: center;"><div class="spinner"></div></div>
    <button id="startBtn" onclick="start()" type="button" class="btn btn-success btn-lg">Start</button>
    <button id="nextBtn" onclick="next()" type="button" class="btn btn-primary btn-lg" disabled>Next</button>
    <button id="endBtn" onclick="end()" type="button" class="btn btn-warning btn-lg" disabled>End</button>
    <button id="reportBtn" onclick="report()" type="button" class="btn btn-warning btn-lg" disabled>Report</button>
    <script src="https://www.gstatic.com/firebasejs/4.9.0/firebase.js"></script>
    <script>
        //Create an account on Firebase, and use the credentials they give you in place of the following
var config = {
  apiKey: "AIzaSyBrIcWjuJ62Ni1M3ds963R6sj-PAU59wvQ",
  authDomain: "videochat-d857b.firebaseapp.com",
  databaseURL: "https://videochat-d857b-default-rtdb.firebaseio.com",
  projectId: "videochat-d857b",
  storageBucket: "videochat-d857b.firebasestorage.app",
  messagingSenderId: "602319735026"
};
firebase.initializeApp(config);

var queueRef = firebase.database().ref('queue');
var signalsRef = firebase.database().ref('signals');
var pairRef = firebase.database().ref('pairs');
var yourVideo = document.getElementById("yourVideo");
var friendsVideo = document.getElementById("friendsVideo");
var statusDiv = document.getElementById("status");
var spinnerDiv = document.getElementById("spinner");
var startBtn = document.getElementById("startBtn");
var nextBtn = document.getElementById("nextBtn");
var endBtn = document.getElementById("endBtn");
var disconnectBtn = document.getElementById("disconnectBtn");
var reportBtn = document.getElementById("reportBtn");
var yourId = Math.floor(Math.random()*1000000000);
var currentPairId = null;
var pc = null;
var localStream = null;
var isConnected = false;
var isWaiting = false;
var queueListenerAttached = false;
var lastStartTime = 0;
//Create an account on Viagenie (http://numb.viagenie.ca/), and replace {'urls': 'turn:numb.viagenie.ca','credential': 'websitebeaver','username': 'websitebeaver@email.com'} with the information from your account
var servers = {'iceServers': [
  {'urls': 'stun:stun.services.mozilla.com'},
  {'urls': 'stun:stun.l.google.com:19302'},
  {'urls': 'turn:numb.viagenie.ca','credential': 'beaver','username': 'webrtc.websitebeaver@gmail.com'},
  {'urls': 'turn:turn.bistri.com:80', 'credential': 'homeo', 'username': 'homeo'},
  {'urls': 'turn:turn.anyfirewall.com:443?transport=tcp', 'credential': 'webrtc', 'username': 'webrtc'}
]};

function updateStatus(message, showSpinner = false) {
  statusDiv.textContent = "Status: " + message;
  spinnerDiv.style.display = showSpinner ? 'block' : 'none';
}

function updateButtons() {
  startBtn.disabled = isWaiting || isConnected;
  nextBtn.disabled = !isConnected;
  endBtn.disabled = !isConnected;
  disconnectBtn.disabled = false;
  reportBtn.disabled = !isConnected;
}

function start() {
  if (isWaiting || isConnected) return;
  var now = Date.now();
  if (now - lastStartTime < 5000) {
    updateStatus("Please wait before starting again.", false);
    return;
  }
  lastStartTime = now;
  // Check queue size first
  queueRef.once('value', (snapshot) => {
    if (snapshot.numChildren() >= 100) {
      updateStatus("Queue is full. Try again later.", false);
      return;
    }
    updateStatus("Requesting camera/microphone access...", true);
    navigator.mediaDevices.getUserMedia({audio:true, video:true})
      .then(stream => {
        localStream = stream;
        yourVideo.srcObject = stream;
        pc = new RTCPeerConnection(servers);
        pc.onconnectionstatechange = () => {
          console.log('Connection state:', pc.connectionState);
          if (pc.connectionState === 'failed') {
            updateStatus("Connection failed. Attempting to reconnect...", true);
            if (pc.restartIce) pc.restartIce();
            setTimeout(() => {
              if (pc.connectionState !== 'connected') {
                updateStatus("Reconnection failed. Click Next for new partner.", false);
                setTimeout(() => { if (isConnected) end(); }, 5000);
              }
            }, 10000);
          } else if (pc.connectionState === 'disconnected') {
            updateStatus("Connection lost. Attempting to reconnect...", true);
            if (pc.restartIce) pc.restartIce();
          } else if (pc.connectionState === 'connected') {
            updateStatus("Connected", false);
          }
        };
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        pc.onicecandidate = (event => event.candidate ? sendMessage(JSON.stringify({'ice': event.candidate})) : console.log("Sent All Ice"));
        pc.ontrack = (event) => {
          friendsVideo.srcObject = event.streams[0];
          isConnected = true;
          updateButtons();
          updateStatus("Connected", false);
        };
        isWaiting = true;
        updateButtons();
        updateStatus("Searching for pair...", true);
        // Add to queue with onDisconnect
        var queueItem = queueRef.push();
        queueItem.set({id: yourId, timestamp: Date.now()});
        queueItem.onDisconnect().remove();
        // Attach queue listener if not already
        if (!queueListenerAttached) {
          queueRef.on('value', handleQueue);
          queueListenerAttached = true;
        }
        // Set timeout for no pair
        pairingTimeout = setTimeout(() => {
          if (isWaiting) {
            updateStatus("No pair found. Click Start to try again.", false);
            end();
          }
        }, 30000);
      })
      .catch(error => {
        console.error('Error accessing media devices.', error);
        updateStatus("Error accessing camera/microphone. Check permissions.", false);
      });
  });

function handleQueue(snapshot) {
  if (!isWaiting || currentPairId) return;
  var queue = snapshot.val();
  if (!queue) return;
  var entries = Object.entries(queue).sort((a,b) => a[1].timestamp - b[1].timestamp);
  if (entries.length >= 2) {
    var [key1, data1] = entries[0];
    var [key2, data2] = entries[1];
    if (data1.id == yourId || data2.id == yourId) {
      // Attempt atomic removal
      queueRef.transaction((current) => {
        if (!current) return;
        var currEntries = Object.entries(current).sort((a,b) => a[1].timestamp - b[1].timestamp);
        if (currEntries.length >= 2 && currEntries[0][1].id == data1.id && currEntries[1][1].id == data2.id) {
          var newQueue = {...current};
          delete newQueue[key1];
          delete newQueue[key2];
          return newQueue;
        }
        return; // abort
      }, (error, committed) => {
        if (committed) {
          currentPairId = data1.id < data2.id ? data1.id + '_' + data2.id : data2.id + '_' + data1.id;
          pairRef.child(currentPairId).set({user1: data1.id, user2: data2.id, timestamp: Date.now()});
          pairRef.child(currentPairId).onDisconnect().remove();
          signalsRef.child(currentPairId).onDisconnect().remove();
          clearTimeout(pairingTimeout);
          updateStatus("Paired! Connecting...", true);
          startSignaling();
        }
      });
    }
  }
}

function startSignaling() {
  if (signalListenerAttached) {
    signalsRef.child(currentPairId).off('child_added', readMessage);
  }
  signalsRef.child(currentPairId).on('child_added', readMessage);
  signalListenerAttached = true;
  // Determine who initiates
  var ids = currentPairId.split('_');
  if (yourId == ids[0]) {
    pc.createOffer()
      .then(offer => pc.setLocalDescription(offer))
      .then(() => sendMessage(JSON.stringify({'sdp': pc.localDescription})))
      .catch(error => {
        console.error('Error creating offer:', error);
        updateStatus("Error establishing connection.", false);
        end();
      });
  }
}

function sendMessage(data) {
  if (currentPairId) {
    signalsRef.child(currentPairId).push({sender: yourId, message: data});
  }
}

function readMessage(data) {
  var msg = JSON.parse(data.val().message);
  var sender = data.val().sender;
  if (sender != yourId) {
    if (msg.ice != undefined) {
      pc.addIceCandidate(new RTCIceCandidate(msg.ice))
        .catch(error => console.error('Error adding ICE candidate:', error));
    } else if (msg.sdp.type == "offer") {
      pc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
        .then(() => pc.createAnswer())
        .then(answer => pc.setLocalDescription(answer))
        .then(() => sendMessage(JSON.stringify({'sdp': pc.localDescription})))
        .catch(error => {
          console.error('Error handling offer:', error);
          updateStatus("Error establishing connection.", false);
          end();
        });
    } else if (msg.sdp.type == "answer") {
      pc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
        .catch(error => {
          console.error('Error setting remote description:', error);
          updateStatus("Error establishing connection.", false);
          end();
        });
    }
  }
}

function next() {
  if (!isConnected) return;
  clearTimeout(pairingTimeout);
  // Close current connection
  if (pc) {
    pc.close();
    pc = null;
  }
  friendsVideo.srcObject = null;
  isConnected = false;
  var oldPairId = currentPairId;
  currentPairId = null;
  if (oldPairId && signalListenerAttached) {
    signalsRef.child(oldPairId).off('child_added', readMessage);
    signalListenerAttached = false;
    // Delete signals
    signalsRef.child(oldPairId).remove();
  }
  updateStatus("Pair ended. Searching for new pair...", true);
  // Re-enter queue
  start();
}

function end() {
  if (!isConnected && !isWaiting) return;
  clearTimeout(pairingTimeout);
  if (pc) {
    pc.close();
    pc = null;
  }
  friendsVideo.srcObject = null;
  isConnected = false;
  var oldPairId = currentPairId;
  currentPairId = null;
  if (oldPairId && signalListenerAttached) {
    signalsRef.child(oldPairId).off('child_added', readMessage);
    signalListenerAttached = false;
    signalsRef.child(oldPairId).remove();
  }
  // Stop listening to queue
  if (queueListenerAttached) {
    queueRef.off('value', handleQueue);
    queueListenerAttached = false;
  }
  isWaiting = false;
  updateButtons();
  updateStatus("Pair ended", false);
}

function disconnect() {
  clearTimeout(pairingTimeout);
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
    yourVideo.srcObject = null;
  }
  if (pc) {
    pc.close();
    pc = null;
    friendsVideo.srcObject = null;
  }
  isConnected = false;
  isWaiting = false;
  var oldPairId = currentPairId;
  currentPairId = null;
  if (oldPairId && signalListenerAttached) {
    signalsRef.child(oldPairId).off('child_added', readMessage);
    signalListenerAttached = false;
    signalsRef.child(oldPairId).remove();
  }
  // Stop listening to queue
  if (queueListenerAttached) {
    queueRef.off('value', handleQueue);
    queueListenerAttached = false;
  }
  // Remove from queue
  queueRef.once('value', (snapshot) => {
    snapshot.forEach(child => {
      if (child.val().id == yourId) child.ref.remove();
    });
  });
  updateButtons();
  updateStatus("Disconnected", false);
}

function report() {
  if (!isConnected || !currentPairId) return;
  var reportsRef = firebase.database().ref('reports');
  reportsRef.push({
    reporter: yourId,
    pairId: currentPairId,
    timestamp: Date.now(),
    reason: 'Reported by user'
  });
  updateStatus("Report submitted. Thank you.", false);
}
    </script>
  </body>
</html>
