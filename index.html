

<html>
  <head>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">

    <style>
        .video-container {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}
video {
  background-color: #ddd;
  border-radius: 7px;
  margin: 10px;
  width: 320px;
  height: 240px;
  max-width: 45%;
}
button {
  margin: 5px;
  width: 150px;
}
@media (max-width: 768px) {
  .video-container {
    flex-direction: column;
    align-items: center;
  }
  video {
    width: 90%;
    max-width: none;
    height: auto;
  }
  button {
    width: 90%;
    margin: 5px auto;
  }
}
    </style>
  </head>
  <body>
    <div class="video-container">
      <video id="yourVideo" autoplay muted playsinline></video>
      <video id="friendsVideo" autoplay playsinline></video>
    </div>
    <br />
    <div id="status" style="margin: 10px; font-weight: bold; text-align: center;">Status: Idle</div>
    <button id="startBtn" onclick="start()" type="button" class="btn btn-success btn-lg">Start</button>
    <button id="nextBtn" onclick="next()" type="button" class="btn btn-primary btn-lg" disabled>Next</button>
    <button id="endBtn" onclick="end()" type="button" class="btn btn-warning btn-lg" disabled>End</button>
    <button id="disconnectBtn" onclick="disconnect()" type="button" class="btn btn-danger btn-lg">Disconnect</button>
    <script src="https://www.gstatic.com/firebasejs/4.9.0/firebase.js"></script>
    <script>
        //Create an account on Firebase, and use the credentials they give you in place of the following
var config = {
  apiKey: "AIzaSyBrIcWjuJ62Ni1M3ds963R6sj-PAU59wvQ",
  authDomain: "videochat-d857b.firebaseapp.com",
  databaseURL: "https://videochat-d857b-default-rtdb.firebaseio.com",
  projectId: "videochat-d857b",
  storageBucket: "videochat-d857b.firebasestorage.app",
  messagingSenderId: "602319735026"
};
firebase.initializeApp(config);

var queueRef = firebase.database().ref('queue');
var signalsRef = firebase.database().ref('signals');
var pairRef = firebase.database().ref('pairs');
var yourVideo = document.getElementById("yourVideo");
var friendsVideo = document.getElementById("friendsVideo");
var statusDiv = document.getElementById("status");
var startBtn = document.getElementById("startBtn");
var nextBtn = document.getElementById("nextBtn");
var endBtn = document.getElementById("endBtn");
var disconnectBtn = document.getElementById("disconnectBtn");
var yourId = Math.floor(Math.random()*1000000000);
var currentPairId = null;
var pc = null;
var localStream = null;
var isConnected = false;
var isWaiting = false;
var queueListenerAttached = false;
var signalListenerAttached = false;
var pairingTimeout = null;
//Create an account on Viagenie (http://numb.viagenie.ca/), and replace {'urls': 'turn:numb.viagenie.ca','credential': 'websitebeaver','username': 'websitebeaver@email.com'} with the information from your account
var servers = {'iceServers': [
  {'urls': 'stun:stun.services.mozilla.com'},
  {'urls': 'stun:stun.l.google.com:19302'},
  {'urls': 'turn:numb.viagenie.ca','credential': 'beaver','username': 'webrtc.websitebeaver@gmail.com'},
  {'urls': 'turn:turn.bistri.com:80', 'credential': 'homeo', 'username': 'homeo'},
  {'urls': 'turn:turn.anyfirewall.com:443?transport=tcp', 'credential': 'webrtc', 'username': 'webrtc'}
]};

function updateStatus(message) {
  statusDiv.textContent = "Status: " + message;
}

function updateButtons() {
  startBtn.disabled = isWaiting || isConnected;
  nextBtn.disabled = !isConnected;
  endBtn.disabled = !isConnected;
  disconnectBtn.disabled = false;
}

function updateButtons() {
  startBtn.disabled = isWaiting || isConnected;
  nextBtn.disabled = !isConnected;
  endBtn.disabled = !isConnected;
  disconnectBtn.disabled = false;
}

function start() {
  if (isWaiting || isConnected) return;
  updateStatus("Requesting camera/microphone access...");
  navigator.mediaDevices.getUserMedia({audio:true, video:true})
    .then(stream => {
      localStream = stream;
      yourVideo.srcObject = stream;
      pc = new RTCPeerConnection(servers);
      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
          updateStatus("Connection failed. Try again.");
          end();
        } else if (pc.connectionState === 'connected') {
          updateStatus("Connected");
        }
      };
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      pc.onicecandidate = (event => event.candidate ? sendMessage(JSON.stringify({'ice': event.candidate})) : console.log("Sent All Ice"));
      pc.ontrack = (event) => {
        friendsVideo.srcObject = event.streams[0];
        isConnected = true;
        updateButtons();
        updateStatus("Connected");
      };
      isWaiting = true;
      updateButtons();
      updateStatus("Searching for pair...");
      // Add to queue with onDisconnect
      var queueItem = queueRef.push();
      queueItem.set({id: yourId, timestamp: Date.now()});
      queueItem.onDisconnect().remove();
      // Attach queue listener if not already
      if (!queueListenerAttached) {
        queueRef.on('value', handleQueue);
        queueListenerAttached = true;
      }
      // Set timeout for no pair
      pairingTimeout = setTimeout(() => {
        if (isWaiting) {
          updateStatus("No pair found. Try again.");
          end();
        }
      }, 30000);
    })
    .catch(error => {
      console.error('Error accessing media devices.', error);
      updateStatus("Error accessing camera/microphone. Check permissions.");
    });
}

function handleQueue(snapshot) {
  if (!isWaiting || currentPairId) return;
  var queue = snapshot.val();
  if (!queue) return;
  var entries = Object.entries(queue).sort((a,b) => a[1].timestamp - b[1].timestamp);
  if (entries.length >= 2) {
    var [key1, data1] = entries[0];
    var [key2, data2] = entries[1];
    if (data1.id == yourId || data2.id == yourId) {
      // Attempt atomic removal
      queueRef.transaction((current) => {
        if (!current) return;
        var currEntries = Object.entries(current).sort((a,b) => a[1].timestamp - b[1].timestamp);
        if (currEntries.length >= 2 && currEntries[0][1].id == data1.id && currEntries[1][1].id == data2.id) {
          var newQueue = {...current};
          delete newQueue[key1];
          delete newQueue[key2];
          return newQueue;
        }
        return; // abort
      }, (error, committed) => {
        if (committed) {
          currentPairId = data1.id < data2.id ? data1.id + '_' + data2.id : data2.id + '_' + data1.id;
          pairRef.child(currentPairId).set({user1: data1.id, user2: data2.id, timestamp: Date.now()});
          clearTimeout(pairingTimeout);
          updateStatus("Paired! Connecting...");
          startSignaling();
        }
      });
    }
  }
}

function startSignaling() {
  if (signalListenerAttached) {
    signalsRef.child(currentPairId).off('child_added', readMessage);
  }
  signalsRef.child(currentPairId).on('child_added', readMessage);
  signalListenerAttached = true;
  // Determine who initiates
  var ids = currentPairId.split('_');
  if (yourId == ids[0]) {
    pc.createOffer()
      .then(offer => pc.setLocalDescription(offer))
      .then(() => sendMessage(JSON.stringify({'sdp': pc.localDescription})))
      .catch(error => {
        console.error('Error creating offer:', error);
        updateStatus("Error establishing connection.");
        end();
      });
  }
}

function sendMessage(data) {
  if (currentPairId) {
    signalsRef.child(currentPairId).push({sender: yourId, message: data});
  }
}

function readMessage(data) {
  var msg = JSON.parse(data.val().message);
  var sender = data.val().sender;
  if (sender != yourId) {
    if (msg.ice != undefined) {
      pc.addIceCandidate(new RTCIceCandidate(msg.ice))
        .catch(error => console.error('Error adding ICE candidate:', error));
    } else if (msg.sdp.type == "offer") {
      pc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
        .then(() => pc.createAnswer())
        .then(answer => pc.setLocalDescription(answer))
        .then(() => sendMessage(JSON.stringify({'sdp': pc.localDescription})))
        .catch(error => {
          console.error('Error handling offer:', error);
          updateStatus("Error establishing connection.");
          end();
        });
    } else if (msg.sdp.type == "answer") {
      pc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
        .catch(error => {
          console.error('Error setting remote description:', error);
          updateStatus("Error establishing connection.");
          end();
        });
    }
  }
}

function next() {
  if (!isConnected) return;
  clearTimeout(pairingTimeout);
  // Close current connection
  if (pc) {
    pc.close();
    pc = null;
  }
  friendsVideo.srcObject = null;
  isConnected = false;
  var oldPairId = currentPairId;
  currentPairId = null;
  if (oldPairId && signalListenerAttached) {
    signalsRef.child(oldPairId).off('child_added', readMessage);
    signalListenerAttached = false;
    // Delete signals
    signalsRef.child(oldPairId).remove();
  }
  updateStatus("Pair ended. Searching for new pair...");
  // Re-enter queue
  start();
}

function end() {
  if (!isConnected && !isWaiting) return;
  clearTimeout(pairingTimeout);
  if (pc) {
    pc.close();
    pc = null;
  }
  friendsVideo.srcObject = null;
  isConnected = false;
  var oldPairId = currentPairId;
  currentPairId = null;
  if (oldPairId && signalListenerAttached) {
    signalsRef.child(oldPairId).off('child_added', readMessage);
    signalListenerAttached = false;
    signalsRef.child(oldPairId).remove();
  }
  // Stop listening to queue
  if (queueListenerAttached) {
    queueRef.off('value', handleQueue);
    queueListenerAttached = false;
  }
  isWaiting = false;
  updateButtons();
  updateStatus("Pair ended");
}

function disconnect() {
  clearTimeout(pairingTimeout);
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
    yourVideo.srcObject = null;
  }
  if (pc) {
    pc.close();
    pc = null;
    friendsVideo.srcObject = null;
  }
  isConnected = false;
  isWaiting = false;
  var oldPairId = currentPairId;
  currentPairId = null;
  if (oldPairId && signalListenerAttached) {
    signalsRef.child(oldPairId).off('child_added', readMessage);
    signalListenerAttached = false;
    signalsRef.child(oldPairId).remove();
  }
  // Stop listening to queue
  if (queueListenerAttached) {
    queueRef.off('value', handleQueue);
    queueListenerAttached = false;
  }
  // Remove from queue
  queueRef.once('value', (snapshot) => {
    snapshot.forEach(child => {
      if (child.val().id == yourId) child.ref.remove();
    });
  });
  updateButtons();
  updateStatus("Disconnected");
}
    </script>
  </body>
</html>
